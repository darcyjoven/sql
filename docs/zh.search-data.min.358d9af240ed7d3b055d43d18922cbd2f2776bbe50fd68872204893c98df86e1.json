[{"id":0,"href":"/docs/SQL/","title":"SQL--结构化查询语言","section":"Docs","content":"SQL 结构化查询语言\r#\r\rDDL 数据定义\r#\r\r建表（必须掌握，简单）\r#\r\r修改表（必须掌握，简单）\r#\r\r删除表（必须掌握，简单）\r#\r\r主键（一般掌握，中等）\r#\r\r索引（一般掌握，中等）\r#\r\r外键（了解，中等）\r#\r\rDML 数据操作\r#\r\r新增（必须掌握，简单）\r#\r\r修改（必须掌握，简单）\r#\r\r删除（必须掌握，简单）\r#\r\rSELECT 查询\r#\r\r查询结果\u0026ndash;字段（必须掌握，简单）\r#\r\r查询来源\u0026ndash;表（必须掌握，简单）\r#\r\r查询条件\u0026ndash;判断语句（必须掌握，中等)\r#\r\r查询排序\u0026ndash;ORDER-BY（必须掌握，简单）\r#\r\r多表查询（必须掌握，中等）\r#\r\r聚合（必须掌握，中等）\r#\r\r嵌套（一般掌握，简单）\r#\r\r常用函数（一般掌握，中等）\r#\r\r视图（必须掌握，中等）\r#\r\r使用SELECT操作数据(一般掌握，中等)\r#\r\r"},{"id":1,"href":"/docs/SQL/hidden/","title":"SQL--结构化查询语言","section":"SQL--结构化查询语言","content":"DDL 数据定义语句\r#\r\r CREATE TABLE ** 需掌握程度 *** ALTER TABLE ** 需掌握程度 *** DROP TABLE * 需掌握程度 ** CREATE INDEX *** 需掌握程度 ** DROP INDEX * 需掌握程度 **  DML 数据操纵语句\r#\r\r  SELECT 难度 ***** 需掌握程度 ****\n 基本语法 cloumn unique/distinct where and、or、not limit order by rownum 聚合 group by min、max count、avg、sum having like (*、？) in、between 子查询（查询嵌套） exists case 别名 join  inner join left/right (outer) join full (outer) join   union (all) insert into select    UPDATE 难度 ** 需掌握程度 ****\n  DELETE 难度 * 需掌握程度 ****\n  INSERT INTO 难度 ** 需掌握程度 ****\n  MERGE 难度 *** 需掌握程度 **\n  "},{"id":2,"href":"/docs/SQL/environment/","title":"环境准备","section":"SQL--结构化查询语言","content":"环境准备\r#\r\r在服务器端可以运行所有功能，但是编辑和排错非常曲折，所以我们推荐使用本地工具连接ORACLE数据库。\n连接数据库，我们需要客户端与官方驱动：\n驱动\r#\r\r 官方驱动，选择对应版本驱动\n 驱动版本位数和客户端要保持一致，要么全都64位，要么全都32位。\n\r64位\n\r32位\n  位数：本次我们都选择64位\n  版本：本次我们选择12.2.0.1.0版本\n  GP5.3 对应的数据版本为11.2.0.3.0，我们可以选择此版本以上的驱动，高版本可以兼容低版本。\n\r 解压：将下载的压缩文件解压到一个文件夹中，后续要用到  本次我们解压位置是D:\\app\\oracle\\instantclient_12_1\n客户端\r#\r\r 我们选择PLSQL Developer，还可以选择NVICAT、Toad for Oracle等\n  下载地址：\rDownload  \r 输入注册码：第一次打开不要登陆，会提示输入注册码，如果没有提示，通过这里打开  \r 设置语言：设置语言为中文  \r\r 设置驱动位置：设置之前解压的驱动文件夹位置  \r 登陆：点击此按钮，或者重新打开软件，即可登陆  \r 测试：新增SQL文件，输入内容，点击执行按钮，如果一下内容说明连接成功  \r"},{"id":3,"href":"/docs/SQL/first/DDL/","title":"DDL--数据定义言","section":"SQL--结构化查询语言","content":"DDL\u0026ndash;数据定义语言\r#\r\r 数据通过表存在数据库中 不区分大小写 表中规定每列的数据名称和数据类型 表结构影响后续数据的存储和检索  ORACLE 数据库结构\r#\r\r 库 TOPPROD 不能库之间只能通过网络通信 用户 FOREWIN 可以直接访问 表 TABLE 存储的基本单元 行 row 每个数据的最小表达方式  建立表\r#\r\rcreate student(  name varchar2(100),  age number(5),  score number(4,2),  birthday date ) 以上代码运行后创建了一个名称 student 的表，其中\n studnet 表名，在有同一个用户中，不能重名，需要满足标识符要求 name 列名，在同一个表中，不能重名，需要满足标识符要求 varchar2(100) 数据类型  oracle 数据类型\r#\r\r date 日期 number() 数字类型 number(5) 为 5 位的小数 number(5,2) 位 5 位，有 2 位小数 blob/clob 二进制大数据 varchar2(100) 长度为 100 的字符串 timestamp 时间戳 （精确到 10 位的秒）  修改表\r#\r\r已有表的修改，请注意已有资料的情况\n增加字段\r#\r\r 无论什么情况，都可以增加字段\n alter table student add (  class varchar2(20),  parent varchar2(20) ) 以上在 student 中增加了两个字段\n减少字段\r#\r\r 如果要减少的字段有任意一笔不为空的资料，不允许删除字段，所以删除字段前，需要先清空字段资料\n \rUPDATE语法\nupdate student set parent = null; alter table student drop column parent;  更新字段值为null 删除字段  修改字段\r#\r\r 修改字段无论是数据类型，还是字段名称，如果已有资料也无法修改\n 通过删除字段\r#\r\r\rUPDATE语法\n 新建临时字段存储要修改列的值 将旧字段值设置为 null 后删除 新增要新增的列 新列的值设置为临时字段 删除临时字段   此方式，最后修改的字段总是在最后\n alter table student add name2 varchar(100); update student set name2 = name; update student set name = null; alter table student drop column name; alter table student add id varchar2(100); update student set id = name2; update student set name2 = null; alter table student drop column name2; 通过重建表\r#\r\r\rUPDATE语法\n 新建临时表存储现表资料 删除现表 重建建立表 将临时表资料储存到新表 删除临时表   此方式，字段的顺序可以受到控制\n create table student2 as select * from student; drop table student; create table student (  id varchar2(100),  age number(5),  score number(4,2),  birthday date ); insert into student select * from student2; drop table student2; 删除表\r#\r\r 删除表比较简单，但要注意备份资料\n drop table student; 主键\r#\r\r将一个或多个字段设置为主键，可以保证资料不重复。\n 一个表最多存在 1 个主键，可以没有主键。主键名和表名一样，在用户中不可重复。\n 例如：身份证，ID 号这些不重复的字段。如果是班级的话，xx 届和 xx 班，两字段加在一起这样也是不重复的。\n创建表时创建主键\r#\r\rcreate table student (  id varchar2(100),  age number(5),  score number(4,2),  birthday date,  constraint student_pk primary key(id) ) 创建表后创建主键\r#\r\rcreate table student (  id varchar2(100),  age number(5),  score number(4,2),  birthday date,  constraint student_pk primary key(id) ); alter table student add constraint student_pk primary key (id); 索引\r#\r\r 索引在表中相当于时目录，如果查询时，走索引速度提升很多。（只在巨量数据时有明显效果，数据库量不多时，没必要考虑索引）\n  查询通过索引可以提高查询速度，但会降低增删改的速度 一个表可以建立多个索引 只有数据量多的时候索引才会明显提升查询速度 只有合适的查询（SELECT）语句才能使用索引查询  创建索引\r#\r\rcreate index student_idx on student(id,age); 删除索引\r#\r\rdrop index student_idx; 重建索引\r#\r\r 删除重新创建即可\n drop index student_idx; create index student_idx on student(id,age); 外键\r#\r\r当a表c1字段必须时b表d1字段中的一个的时候，可以将c1设置为d1字段的外键。这样在新增a表资料时，c1字段会自动检查是否在b表中存在，不存在不允许新增该资料。\n 创建外键，会时两个表耦合性增加，且不利于问题排查，所以不建议使用，了解有这个东西即可。这个检查可以通过代码实现。\n 创建\r#\r\r 创建表时创建  create table class (  id number(10) ); create table student(  id number(10),  class number(10)  constraint student_fk  foreign key (class)  references class (id) ); 创建表后创建  create table class (  id number(10) ); create table student(  id number(10),  class number(10) ); alter table student add constraint student_fk  foreign key (class)  references class (id); 删除\r#\r\ralter table student drop constraint student_fk 重建\r#\r\r删除后重新添加即可\n"},{"id":4,"href":"/docs/SQL/first/SELECT/join/","title":"多表查询","section":"查询语句详解","content":"多表查询\r#\r\r资料准备\n-- table1 : create table user1(id number(3), user_name varchar(10), over varchar(10)); insert into user1 values(1, \u0026#39;tangseng\u0026#39;, \u0026#39;dtgdf\u0026#39;); insert into user1 values(2, \u0026#39;sunwukong\u0026#39;, \u0026#39;dzsf\u0026#39;); insert into user1 values(1, \u0026#39;zhubajie\u0026#39;, \u0026#39;jtsz\u0026#39;); insert into user1 values(1, \u0026#39;shaseng\u0026#39;, \u0026#39;jslh\u0026#39;); -- table2 : create table user2(id number(3), user_name varchar(10), over varchar(10)); insert into user2 values(1, \u0026#39;sunwukong\u0026#39;, \u0026#39;chengfo\u0026#39;); insert into user2 values(2, \u0026#39;niumowang\u0026#39;, \u0026#39;chengyao\u0026#39;); insert into user2 values(3, \u0026#39;jiaomowang\u0026#39;, \u0026#39;chengyao\u0026#39;); insert into user2 values(4, \u0026#39;pengmowang\u0026#39;, \u0026#39;chengyao\u0026#39;); INNER 内连接\r#\r\r\rselect a.id, a.user_name, b.over from user1 a inner join user2 b on a.user_name=b.user_name; ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\r LEFT/RIGHT\r#\r\rLEFT\r#\r\r\r left join是left outer join的缩写，outer 可以不写\n select a.id, a.user_name, b.over from user1 a left outer join user2 b on a.user_name=b.user_name; ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\r1 shaseng\r1 zhubajie\r1 tangseng\r RIGHT\r#\r\r\r left join和right join区别就是量表的顺序不同，所以 a left join b和b right join a 是完全等效的，所以right join不必学习，使用时仅使用left join即可\n select b.user_name, b.over, a.over from user1 a right join user2 b on a.user_name=b.user_name; USER_NAME OVER OVER\r---------- ---------- ----------\rsunwukong chengfo dzsf\rniumowang chengyao\rjiaomowang chengyao\rpengmowang chengyao\r FULL\r#\r\r\r select a.id, a.user_name, b.over from user1 a full join user2 b on a.user_name=b.user_name ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\rchengyao\rchengyao\rchengyao\r1 shaseng\r1 zhubajie\r1 tangseng\r 笛卡尔连接(交叉连接)\r#\r\r\r a,b是a cross b的缩写，通常情况下，我们会进一步使用 where 条件筛选资料\n select a.id,a.user_name,b.id,b.user_name from user1 a,user2 b; ID USER_NAME ID USER_NAME\r---- ---------- ---- ----------\r1 tangseng 1 sunwukong\r1 tangseng 2 niumowang\r1 tangseng 3 jiaomowang\r1 tangseng 4 pengmowang\r2 sunwukong 1 sunwukong\r2 sunwukong 2 niumowang\r2 sunwukong 3 jiaomowang\r2 sunwukong 4 pengmowang\r1 zhubajie 1 sunwukong\r1 zhubajie 2 niumowang\r1 zhubajie 3 jiaomowang\r1 zhubajie 4 pengmowang\r1 shaseng 1 sunwukong\r1 shaseng 2 niumowang\r1 shaseng 3 jiaomowang\r1 shaseng 4 pengmowang\r select a.id, a.user_name, b.over from user1 a,user2 b where a.user_name=b.user_name;  以上笛卡尔连接，配合where条件等效以下内连接，所以内连接也不需要学。\n select a.id, a.user_name, b.over from user1 a inner join user2 b on a.user_name=b.user_name; ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\r 总结\r#\r\r综上所述，我们只要笛卡尔连接，和LEFT左连接就可以解锁99%的场景，剩下1%场景，我们可以使用代码协助。\n  笛卡尔连接，两个表都存在数据，才会显示出来\n  LEFT 连接，只要左表存在数据，右表数据为NULL也会显示出来\n  "},{"id":5,"href":"/docs/SQL/first/DML/","title":"DML--数据操作语言","section":"SQL--结构化查询语言","content":"DML\u0026ndash;数据操作语言\r#\r\r新增\r#\r\r已知表student结构如下:\ncreate table student(  id number(10),  name varchar(20),  sex varchar(20),  age number(5),  birthday date ) insert into student values(1,\u0026#39;张三\u0026#39;,\u0026#39;男\u0026#39;,19,to_date(\u0026#39;951221\u0026#39;,\u0026#39;yymmdd\u0026#39;)); insert into student (name,id,age) values(\u0026#39;小红\u0026#39;,2,19); 修改\r#\r\r ID NAME SEX AGE BIRTHDAY\r----------- -------------------- -------------------- ------ -----------\r1 张三 男 19 2095-12-21\r2 小红 19  student资料如上\n-- 1.更新小红性别为女 update student set sex=\u0026#39;女\u0026#39; where name=\u0026#39;小红\u0026#39;; -- 2.将所有人年龄更新为12 update student set age=12; 删除\r#\r\r ID NAME SEX AGE BIRTHDAY\r----------- -------------------- -------------------- ------ -----------\r1 张三 男 12 2095-12-21\r2 小红 女 12  student资料如上\n-- 1. 删除所有性别为男资料 delete from student where sex=\u0026#39;男\u0026#39;; -- 2. 删除所有资料 delete from student;  update和delete使用到了where语句，我们在select中会详细介绍和使用。\n "},{"id":6,"href":"/docs/SQL/first/SELECT/group/","title":"聚合查询","section":"查询语句详解","content":"聚合查询\r#\r\r聚合查询是一个比较特殊的查询，它不返回数据，而是返回一个聚合结果，比如求和、平均值、最大值、最小值等。\n数据准备:\nCREATE TABLE sales(  location varchar2(10),  product varchar2(10),  price number(3),  sold_at date );  INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate-1); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;Downtown\u0026#39;, \u0026#39;Bagel\u0026#39;, 3, sysdate-3); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;Downtown\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate-2); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Bagel\u0026#39;, 2, sysdate-2); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;1st Street\u0026#39;, \u0026#39;Bagel\u0026#39;, 3, sysdate-1); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;1st Street\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate-1); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Bagel\u0026#39;, 3, sysdate-5); GROUP-BY\r#\r\r GROUP BY位置紧跟WHERE条件之后\n GROUP-BY 是聚合函数的核心，SELECT的查询结果会依据GROUP BY字段进行汇总。\nSELECT location FROM sales GROUP BY location; LOCATION\r----------\rHQ\rDowntown\r1st Street\r 试一下以下查询：\nSELECT  location,  product FROM sales GROUP BY location; 聚合函数\r#\r\r sum() 合计 count() 计数 avg() 平均值 max() 最大值 min() 最小值  SELECT  location,  COUNT(*) AS number_of_sales FROM sales GROUP BY location; LOCATION NUMBER_OF_SALES\r---------- ---------------\rHQ 4\rDowntown 2\r1st Street 2\r SELECT  location，  sold_at,  COUNT(*) AS sales_per_day FROM sales GROUP BY location,sold_at ORDER BY location,sold_at; LOCATION SOLD_AT SALES_PER_DAY\r---------- ----------- -------------\r1st Street 2023-10-15 2\rDowntown 2023-10-13 1\rDowntown 2023-10-14 1\rHQ 2023-10-11 1\rHQ 2023-10-14 1\rHQ 2023-10-15 1\rHQ 2023-10-16 1\r HAVING\r#\r\r 紧跟GROUP BY\n 在聚合的基础上进行筛选。\nSELECT  location，  sold_at,  COUNT(*) AS sales_per_day FROM sales GROUP BY location,sold_at HAVING COUNT(*) = 1 ORDER BY location,sold_at; LOCATION SOLD_AT SALES_PER_DAY\r---------- ----------- -------------\rDowntown 2023-10-13 1\rDowntown 2023-10-14 1\rHQ 2023-10-11 1\rHQ 2023-10-14 1\rHQ 2023-10-15 1\rHQ 2023-10-16 1\r 隐式聚合\r#\r\rselect count(*) from sales; COUNT(*)\r----------\r8\r 总结\r#\r\rSELECT 中关键字顺序：\n SELECT 必须 FROM 必须 JOIN WHERE GROUP BY HAVING ORDER BY  "},{"id":7,"href":"/docs/SQL/first/SELECT/","title":"查询语句详解","section":"SQL--结构化查询语言","content":"SELECT\u0026ndash;查询语句详解\r#\r\r查询语句组成\r#\r\r结果\u0026ndash;字段（select）\r#\r\r 查询语句的最前面\n select 字段1,字段2,字段3,\u0026#39;6班\u0026#39; 班级  * 匹配所有字段:  select * select student.*,class.*   字面常量： 数值和字符串都可以以字面常量作为字段结果\n  别名：\n  select id,name 姓名,age as 年纪 查询结果中会以别名显示\n 字段运算:  select id,\u0026#39;姓名\u0026#39;||name,age+2 查询字段可以进行字段运算，字符串拼接为||拼接，数学运算符号+-*/都可以使用\n 判断语句： SQL 中判断语句比较特殊，它只能返回一个值，且每个分支返回值必须一致。  -- 从一个变量的值判断 select case sex when \u0026#39;男\u0026#39; then \u0026#39;我是男生\u0026#39; when \u0026#39;女\u0026#39; then \u0026#39;我是女生\u0026#39; else \u0026#39;我是人妖\u0026#39; end as 性别 -- 从条件表达式判断 select case when age \u0026lt; 8 then \u0026#39;小学生\u0026#39; when age \u0026lt; 16 then \u0026#39;初中生\u0026#39; when age \u0026lt; 24 \u0026#39;大学生\u0026#39; else \u0026#39;老人\u0026#39; end as 年纪 来源\u0026ndash;表（from）\r#\r\r 必须在字段之后\n from student,class  别名：  from student as s  表字段:  select s.id,class.id from student as s,class 当多个表中字段有重名时，使用字段必须指定字段属于哪个表\n条件\u0026ndash;判断语句（where）\r#\r\r 必须放在 from 之后\n where student.id \u0026gt; 1 and student.name like \u0026#39;张%\u0026#39; and student.id=class.id and (student.age \u0026gt; 18 or student.age \u0026lt; 10) and student.birth between to_date(\u0026#39;2000-01-01\u0026#39;,\u0026#39;yyyy-mm-dd\u0026#39;) and to_date(\u0026#39;2020-12-31\u0026#39;,\u0026#39;yyyy-mm-dd\u0026#39;) and sex in (\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;)  where 可以从众多的资料中筛选出符号目标要求的资料，所以 where 在查询语句中是最复杂的。\n  我们在写 where 语句的时候，应该从简单语句开始写，分块写，防止多个筛选条件混合到一起。\n  比较运算符： 大于、小于、等于这些运算符在 where 中也可以写。  \u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;/!=\n 逻辑运算符： 多个运算符之间用and或者or相连。 括号会改变判断语句运算顺序  -- 年纪大于10岁或者小于5岁的女人 where (age \u0026gt; 10 or age \u0026lt; 5) and sex =\u0026#39;女\u0026#39; -- 年纪大于10岁的人或者小于5岁的女人 where age \u0026gt; 10 or (age \u0026lt; 5 and sex =\u0026#39;女\u0026#39;)  模糊查询： 字符串模糊查询，like 运算符， %匹配任意多(包括 0)个任意字符， _匹配一个任意字符  -- 匹配\u0026#39;张\u0026#39;开始的字符串 张三 张 张98ahs 等都符和 where name like \u0026#39;张%\u0026#39; -- 匹配\u0026#39;张\u0026#39;开始，且后面之后一个字符的字符串 张三 张四 张w 符和 张 张sw 不符合 where name like \u0026#39;张_\u0026#39; -- 匹配字符中有一个\u0026#39;h\u0026#39;和\u0026#39;o\u0026#39;,且\u0026#39;h\u0026#39;在\u0026#39;o\u0026#39;前面， hello hsasaodaidup ooohhooo 都符和 where name like \u0026#39;%h%o\u0026#39;  between 范围判断:  between 可以判断一个连续的区间，数值，日期，单个字符都可以判断。\n 这里的and 和上面的and不是同一个意思。\n -- 年纪在1到10之间 where age between 1 and 10  in 范围判断： in 判断一个值是否在某个范围之内，这个不是连续的，而是一个集合。  -- 年纪是1，2，10 where age in (1,2,10) -- 年纪不是18，19 where age not in (18,19) -- 可以是多个字段 where (name,age) in ((\u0026#39;darcy\u0026#39;,19),(\u0026#39;joven\u0026#39;,10)) 顺序\u0026ndash;排序（order-by）\r#\r\r 在 sql 语句的最后一步写，不一定是 where 后\n  可以不排序，此时数据库按照查出来的顺序排序\n order by name,age desc,id esc   多字段： 排序是按照字段先后顺序排，如果第一个字段有相同，才会按照第二个字段排序，第二个也相同，才会按第三个\u0026hellip;\n  顺序/倒叙: 顺序是按照 ASCII 表中数字大小排序的，中文是按照 GBK 表中数字大小排序的（既不是笔画也不是拼音）。\n  esc是顺序，desc是倒叙，如果补标注默认是esc倒叙\n"},{"id":8,"href":"/docs/SQL/first/SELECT/nest/","title":"嵌套查询","section":"查询语句详解","content":"嵌套查询\r#\r\r资料准备：\nCREATE TABLE CUSTOMERS (  ID number(2),  NAME VARCHAR2(8),  AGE number(3),  ADDRESS VARCHAR2 (10),  SALARY number (10, 2) );  INSERT INTO CUSTOMERS VALUES (1, \u0026#39;Ramesh\u0026#39;, 32, \u0026#39;Ahmedabad\u0026#39;, 2000.00); INSERT INTO CUSTOMERS VALUES (2, \u0026#39;Khilan\u0026#39;, 25, \u0026#39;Delhi\u0026#39;, 1500.00); INSERT INTO CUSTOMERS VALUES (3, \u0026#39;Kaushik\u0026#39;, 23, \u0026#39;Kota\u0026#39;, 2000.00); INSERT INTO CUSTOMERS VALUES (4, \u0026#39;Chaitali\u0026#39;, 25, \u0026#39;Mumbai\u0026#39;, 6500.00); INSERT INTO CUSTOMERS VALUES (5, \u0026#39;Hardik\u0026#39;, 27, \u0026#39;Bhopal\u0026#39;, 8500.00); INSERT INTO CUSTOMERS VALUES (6, \u0026#39;Komal\u0026#39;, 22, \u0026#39;Hyderabad\u0026#39;, 4500.00); INSERT INTO CUSTOMERS VALUES (7, \u0026#39;Muffy\u0026#39;, 24, \u0026#39;Indore\u0026#39;, 10000.00); 作为结果-SELECT\r#\r\r作为查询结果字段，这个时候要保证每次查询结果只有一个值。\n查询每个人的薪水和最高薪水的差异金额\nselect a.name,a.salary,a.salary-(select max(b.salary) from customers b) salary_diff from customers a; NAME SALARY SALARY_DIFF\r-------- ------------ -----------\rRamesh 2000.00 -8000\rKhilan 1500.00 -8500\rKaushik 2000.00 -8000\rChaitali 6500.00 -3500\rHardik 8500.00 -1500\rKomal 4500.00 -5500\rMuffy 10000.00 0\r 作为条件-WHERE\r#\r\rin\r#\r\r查询工资不是最高也不是最低的人\nselect name,salary from customers where salary not in (  (select max(salary) from customers),  (select min(salary) from customers) ); NAME SALARY\r-------- ------------\rRamesh 2000.00\rKaushik 2000.00\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\r in除了查询单个值，还可以作为范围条件。\nselect name,salary from customers where salary in (select salary from customers where salary \u0026gt; 4000);  和in 一样，这里可以是多字段\n 以上查询，查询薪水大于 4000 的人，当然有更简单的方式写，这里知识演示用法。\nNAME SALARY\r-------- ------------\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\rMuffy 10000.00\r exists\r#\r\rexists和in可以互相转化，查询工资不是最高也不是最低的人改为exists写为：\nselect a.name,a.salary from customers a where not exists (select max(b.salary) from customers b having max(b.salary)=a.salary) and not exists (select min(b.salary) from customers b having max(b.salary)=a.salary); NAME SALARY\r-------- ------------\rRamesh 2000.00\rKhilan 1500.00\rKaushik 2000.00\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\r 作为字段\r#\r\r和SELECT一样，在WHERE查询条件中，也可以将子查询作为查询条件，这个时候要保证查询结果只有一个值。\n同样是查询工资不是最高也不是最低的人\nselect name,salary from customers where salary \u0026lt; (select max(salary) from customers) and salary \u0026gt; (select min(salary) from customers); NAME SALARY\r-------- ------------\rRamesh 2000.00\rKaushik 2000.00\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\r 作为来源-FROM\r#\r\r查询结果可以当作一个表使用，即可以作为FROM和JOIN的来源。这个时候要保证，列名不重复（因为表的列名不重复）。\n查询工资最高的人的姓名和地址\nselect a.name,a.address,a.salary from customers a,(select max(salary) salary from customers) b where a.salary=b.salary; NAME ADDRESS SALARY\r-------- ---------- ------------\rMuffy Indore 10000.00\r 总结\r#\r\r  查询结果为多笔时，可用在FROM、JOIN、IN、EXISTS\n  查询结果为单笔，可以当作字段、单个值使用\n  "},{"id":9,"href":"/docs/SQL/first/SELECT/function/","title":"常用函数","section":"查询语句详解","content":"常用函数\r#\r\r数字\r#\r\r绝对值\r#\r\rselect abs(-12) from dual; select abs(12) from dual; 取整\r#\r\r-- 大于该数的最小整数 select ceil(20.2) from dual; -- 小于该数的最大整数 select floor(20.2) from dual; 四舍五入\r#\r\rselect round(20.679,2) from dual 求余数\r#\r\rselect mod(10,3) from dual 截取部分值\r#\r\rselect trunc(20.9987,3) from dual 字符串\r#\r\r拼接\r#\r\rselect \u0026#39;hello\u0026#39;||\u0026#39; world\u0026#39;||\u0026#39;!\u0026#39; from dual; 大小写\r#\r\rselect lower(\u0026#39;Hello\u0026#39;) from dual; select upper(\u0026#39;Hello\u0026#39;) from dual; 替换\r#\r\rselect replace(\u0026#39;hello,darcy\u0026#39;,\u0026#39;darcy\u0026#39;,\u0026#39;joven\u0026#39;)from dual; 去空格\r#\r\rselect \u0026#39;hi,\u0026#39;||rtrim(\u0026#39; hello \u0026#39;)||\u0026#39;joven\u0026#39; from dual; select \u0026#39;hi,\u0026#39;||ltrim(\u0026#39; hello \u0026#39;)||\u0026#39;joven\u0026#39; from dual; select \u0026#39;hi,\u0026#39;||trim(\u0026#39; hello \u0026#39;)||\u0026#39;joven\u0026#39; from dual; 截取部分字符串\r#\r\rselect substr(\u0026#39;hello world\u0026#39;,8,2) from dual; 日期\r#\r\r当前时间\r#\r\rselect current_date,sysdate from dual; 最近日期\r#\r\rselect round(sysdate,\u0026#39;yyyy\u0026#39;),round(sysdate,\u0026#39;mm\u0026#39;),round(sysdate,\u0026#39;dd\u0026#39;),round(sysdate,\u0026#39;hh\u0026#39;) from dual; 截取日期\r#\r\rselect trunc(sysdate,\u0026#39;yyyy\u0026#39;),trunc(sysdate,\u0026#39;mm\u0026#39;),trunc(sysdate,\u0026#39;dd\u0026#39;),trunc(sysdate,\u0026#39;hh\u0026#39;) from dual; 日期与字符串转换\r#\r\rselect to_char(sysdate,\u0026#39;yy/mm/dd hh:mi:ss\u0026#39;), to_date(\u0026#39;231017\u0026#39;,\u0026#39;yymmdd\u0026#39;) from dual 日期计算\r#\r\rselect sysdate-1, sysdate + 1/24/2 from dual "},{"id":10,"href":"/docs/SQL/first/SELECT/view/","title":"视图","section":"查询语句详解","content":"视图\r#\r\r视图-VIEW是通过查询结果建立的一个对象\n 视图必须通过查询结果建立，列名不可重复 视图不储存数据，数据仍在原表 视图每次查询重新查询资料  建立视图\r#\r\rcreate view stu_view as select name,id form student 删除视图\r#\r\rdrop view stu_view 重建视图\r#\r\rcreate or replace view stu_view as select name,id form student "},{"id":11,"href":"/docs/SQL/first/SELECT/dmlBySelect/","title":"使用SELECT更新数据","section":"查询语句详解","content":"使用SELECT更新数据\r#\r\r新增数据-INSERT\r#\r\r在insert语句中除了使用values()还可以使用select，且查询结果可以是多笔。\ninsert into student (id,name) select id,name from student2; 创建表-CREATE\r#\r\r和创建视图一样，通过SELECT还可以创建table\ncreate table student3 as select id,name from student2; "}]