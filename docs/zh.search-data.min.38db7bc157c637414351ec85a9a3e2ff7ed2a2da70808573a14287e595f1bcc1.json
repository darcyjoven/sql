[{"id":0,"href":"/docs/SQL/","title":"SQL--结构化查询语言","section":"Docs","content":"SQL 结构化查询语言\r#\r\rDDL 数据定义\r#\r\r建表（必须掌握，简单）\r#\r\r修改表（必须掌握，简单）\r#\r\r删除表（必须掌握，简单）\r#\r\r主键（一般掌握，中等）\r#\r\r索引（一般掌握，中等）\r#\r\r外键（了解，中等）\r#\r\rDML 数据操作\r#\r\r新增（必须掌握，简单）\r#\r\r修改（必须掌握，简单）\r#\r\r删除（必须掌握，简单）\r#\r\rSELECT 查询\r#\r\r查询结果\u0026ndash;字段（必须掌握，简单）\r#\r\r查询来源\u0026ndash;表（必须掌握，简单）\r#\r\r查询条件\u0026ndash;判断语句（必须掌握，中等)\r#\r\r查询排序\u0026ndash;ORDER-BY（必须掌握，简单）\r#\r\r多表查询（必须掌握，中等）\r#\r\r聚合（必须掌握，中等）\r#\r\r嵌套（一般掌握，简单）\r#\r\r常用函数（一般掌握，中等）\r#\r\r视图（必须掌握，中等）\r#\r\r使用SELECT操作数据(一般掌握，中等)\r#\r\r"},{"id":1,"href":"/docs/SQL/hidden/","title":"SQL--结构化查询语言","section":"SQL--结构化查询语言","content":"DDL 数据定义语句\r#\r\r CREATE TABLE ** 需掌握程度 *** ALTER TABLE ** 需掌握程度 *** DROP TABLE * 需掌握程度 ** CREATE INDEX *** 需掌握程度 ** DROP INDEX * 需掌握程度 **  DML 数据操纵语句\r#\r\r  SELECT 难度 ***** 需掌握程度 ****\n 基本语法 cloumn unique/distinct where and、or、not limit order by rownum 聚合 group by min、max count、avg、sum having like (*、？) in、between 子查询（查询嵌套） exists case 别名 join  inner join left/right (outer) join full (outer) join   union (all) insert into select    UPDATE 难度 ** 需掌握程度 ****\n  DELETE 难度 * 需掌握程度 ****\n  INSERT INTO 难度 ** 需掌握程度 ****\n  MERGE 难度 *** 需掌握程度 **\n  "},{"id":2,"href":"/docs/SQL/environment/","title":"环境准备","section":"SQL--结构化查询语言","content":"环境准备\r#\r\r在服务器端可以运行所有功能，但是编辑和排错非常曲折，所以我们推荐使用本地工具连接ORACLE数据库。\n连接数据库，我们需要客户端与官方驱动：\n驱动\r#\r\r 官方驱动，选择对应版本驱动\n 驱动版本位数和客户端要保持一致，要么全都64位，要么全都32位。\n\r64位\n\r32位\n  位数：本次我们都选择64位\n  版本：本次我们选择12.2.0.1.0版本\n  GP5.3 对应的数据版本为11.2.0.3.0，我们可以选择此版本以上的驱动，高版本可以兼容低版本。\n\r 解压：将下载的压缩文件解压到一个文件夹中，后续要用到  本次我们解压位置是D:\\app\\oracle\\instantclient_12_1\n客户端\r#\r\r 我们选择PLSQL Developer，还可以选择NVICAT、Toad for Oracle等\n  下载地址：\rDownload  \r 输入注册码：第一次打开不要登陆，会提示输入注册码，如果没有提示，通过这里打开  \r 设置语言：设置语言为中文  \r\r 设置驱动位置：设置之前解压的驱动文件夹位置  \r 登陆：点击此按钮，或者重新打开软件，即可登陆  \r 测试：新增SQL文件，输入内容，点击执行按钮，如果一下内容说明连接成功  \rSQL*Plus 客户端\r#\r\r SQL*Plus 客户端，是ORACLE官方提供的命令行客户端，可以使用命令行连接数据库\n  在运维时，我们偶尔需要连接SQL*Plus客户端，所以要知道如何简单使用\n 在数据库服务器和EPR服务器都安装好了SQL*Plus客户端，所以可以直接使用。\n 连接命令   sqlplus [username]/[password]@[host]:[port]/[sid]  sqlplus system/password@topprod  sqlplus / as sysdba  退出命令   quit  SQL*Plus中运行的SQL语句需要提交（commit;）并以;作为结束。\n "},{"id":3,"href":"/docs/SQL/first/frame/","title":"ORACLE数据库结构","section":"SQL--结构化查询语言","content":"ORACLE 数据库结构\r#\r\r物理结构-表空间\r#\r\rTABLEPACE\u0026ndash;表空间\r#\r\r数据库存储数据的物理文件，所有数据库的表资料都储存在不同的表空间中。\nSQL\u0026gt; SELECT TABLESPACE_NAME,  2 STATUS,  3 CONTENTS,  4 LOGGING  5 FROM DBA_TABLESPACES;  TABLESPACE_NAME STATUS CONTENTS LOGGING ------------------------------ --------- --------- --------- SYSTEM ONLINE PERMANENT LOGGING SYSAUX ONLINE PERMANENT LOGGING UNDOTBS1 ONLINE UNDO LOGGING TEMP ONLINE TEMPORARY NOLOGGING USERS ONLINE PERMANENT LOGGING DBS1 ONLINE PERMANENT LOGGING TEMPTABS ONLINE PERMANENT LOGGING RPTDBS1 ONLINE PERMANENT LOGGING BLOBDBS1 ONLINE PERMANENT LOGGING 表空间文件\r#\r\r表空间是表空间文件组成，表空间文件在建立时就定义了大小，当表空间文件满时，需要增加表空间文件。已建立表空间文件不能删除，移动，变小。\nSQL\u0026gt; SELECT TABLESPACE_NAME,  2 \u0026#39;PERMANENT\u0026#39; TABLESPACE_KIND,  3 FILE_NAME,  4 STATUS,  5 AUTOEXTENSIBLE,  6 BYTES/1024/1024 CURR_BYTES_M,  7 ONLINE_STATUS  8 FROM DBA_DATA_FILES --永久表空间（含撤销表空间）  9 UNION ALL  10 SELECT TABLESPACE_NAME,  11 \u0026#39;TEMPORARY\u0026#39; TABLESPACE_KIND,  12 FILE_NAME,  13 STATUS,  14 AUTOEXTENSIBLE,  15 BYTES/1024/1024 CURR_BYTES_M,  16 \u0026#39;ONLINE\u0026#39; ONLINE_STATUS  17 FROM DBA_TEMP_FILES;  TABLESPACE_NAME TABLESPACE_KIND FILE_NAME STATUS AUTOEXTENSIBLE CURR_BYTES_M ONLINE_STATUS ------------------------------ --------------- -------------------------------------------------------------------------------- --------- -------------- ------------ ------------- SYSTEM PERMANENT /u2/oracle/oradata/topprod/system01.dbf AVAILABLE YES 32750 SYSTEM SYSAUX PERMANENT /u2/oracle/oradata/topprod/sysaux01.dbf AVAILABLE YES 1030 ONLINE UNDOTBS1 PERMANENT /u2/oracle/oradata/topprod/undotbs01.dbf AVAILABLE YES 32767.984375 ONLINE USERS PERMANENT /u2/oracle/oradata/topprod/users01.dbf AVAILABLE YES 6466.25 ONLINE DBS1 PERMANENT /u2/oracle/oradata/topprod/dbs1-01.dbf AVAILABLE NO 2000 ONLINE  表空间满了之后，需要增加表空间文件，任何表空间的操作都需要管理员账号登陆\n 逻辑结构\r#\r\r SID \u0026ndash; 库  库为数据库的第一层结构，GP5.3中库名对应区。\n如topprod对应ERP正式区，toptest对应ERP测试区。\n不同库之间不能直接访问，需要通过网络访问。\nuser \u0026ndash; 用户  用户是库之下的第二层结构，在GP5.3中用户对应的是营运据点\n如forewin对应的就是forewin这个营运据点。\n不同用户之间资料，可以通过赋予权限访问。\n第三次结构：table、view、index\u0026hellip;  存储数据的基本单元表\u0026ndash;table，以及索引、视图、触发器等，都属于一个用户。 也就是这些数据结构都建立并储存在用户下面。\n"},{"id":4,"href":"/docs/SQL/first/DDL/","title":"DDL--数据定义言","section":"SQL--结构化查询语言","content":"DDL\u0026ndash;数据定义语言\r#\r\r 数据通过表存在数据库中 不区分大小写 表中规定每列的数据名称和数据类型 表结构影响后续数据的存储和检索  建立表\r#\r\rcreate student(  name varchar2(100),  age number(5),  score number(4,2),  birthday date ) 以上代码运行后创建了一个名称 student 的表，其中\n studnet 表名，在有同一个用户中，不能重名，需要满足标识符要求 name 列名，在同一个表中，不能重名，需要满足标识符要求 varchar2(100) 数据类型  oracle 数据类型\r#\r\r date 日期 number() 数字类型 number(5) 为 5 位的小数 number(5,2) 位 5 位，有 2 位小数 blob/clob 二进制大数据 varchar2(100) 长度为 100 的字符串 timestamp 时间戳 （精确到 10 位的秒）  修改表\r#\r\r已有表的修改，请注意已有资料的情况\n增加字段\r#\r\r 无论什么情况，都可以增加字段\n alter table student add (  class varchar2(20),  parent varchar2(20) ) 以上在 student 中增加了两个字段\n减少字段\r#\r\r 如果要减少的字段有任意一笔不为空的资料，不允许删除字段，所以删除字段前，需要先清空字段资料\n \rUPDATE语法\nupdate student set parent = null; alter table student drop column parent;  更新字段值为null 删除字段  修改字段\r#\r\r 修改字段无论是数据类型，还是字段名称，如果已有资料也无法修改\n 通过删除字段\r#\r\r\rUPDATE语法\n 新建临时字段存储要修改列的值 将旧字段值设置为 null 后删除 新增要新增的列 新列的值设置为临时字段 删除临时字段   此方式，最后修改的字段总是在最后\n alter table student add name2 varchar(100); update student set name2 = name; update student set name = null; alter table student drop column name; alter table student add id varchar2(100); update student set id = name2; update student set name2 = null; alter table student drop column name2; 通过重建表\r#\r\r\rUPDATE语法\n 新建临时表存储现表资料 删除现表 重建建立表 将临时表资料储存到新表 删除临时表   此方式，字段的顺序可以受到控制\n create table student2 as select * from student; drop table student; create table student (  id varchar2(100),  age number(5),  score number(4,2),  birthday date ); insert into student select * from student2; drop table student2; 删除表\r#\r\r 删除表比较简单，但要注意备份资料\n drop table student; 主键\r#\r\r将一个或多个字段设置为主键，可以保证资料不重复。\n 一个表最多存在 1 个主键，可以没有主键。主键名和表名一样，在用户中不可重复。\n 例如：身份证，ID 号这些不重复的字段。如果是班级的话，xx 届和 xx 班，两字段加在一起这样也是不重复的。\n创建表时创建主键\r#\r\rcreate table student (  id varchar2(100),  age number(5),  score number(4,2),  birthday date,  constraint student_pk primary key(id) ) 创建表后创建主键\r#\r\rcreate table student (  id varchar2(100),  age number(5),  score number(4,2),  birthday date,  constraint student_pk primary key(id) ); alter table student add constraint student_pk primary key (id); 索引\r#\r\r 索引在表中相当于时目录，如果查询时，走索引速度提升很多。（只在巨量数据时有明显效果，数据库量不多时，没必要考虑索引）\n  查询通过索引可以提高查询速度，但会降低增删改的速度 一个表可以建立多个索引 只有数据量多的时候索引才会明显提升查询速度 只有合适的查询（SELECT）语句才能使用索引查询  创建索引\r#\r\rcreate index student_idx on student(id,age); 删除索引\r#\r\rdrop index student_idx; 重建索引\r#\r\r 删除重新创建即可\n drop index student_idx; create index student_idx on student(id,age); 外键\r#\r\r当a表c1字段必须时b表d1字段中的一个的时候，可以将c1设置为d1字段的外键。这样在新增a表资料时，c1字段会自动检查是否在b表中存在，不存在不允许新增该资料。\n 创建外键，会时两个表耦合性增加，且不利于问题排查，所以不建议使用，了解有这个东西即可。这个检查可以通过代码实现。\n 创建\r#\r\r 创建表时创建  create table class (  id number(10) ); create table student(  id number(10),  class number(10)  constraint student_fk  foreign key (class)  references class (id) ); 创建表后创建  create table class (  id number(10) ); create table student(  id number(10),  class number(10) ); alter table student add constraint student_fk  foreign key (class)  references class (id); 删除\r#\r\ralter table student drop constraint student_fk 重建\r#\r\r删除后重新添加即可\n"},{"id":5,"href":"/docs/SQL/first/SELECT/join/","title":"多表查询","section":"查询语句详解","content":"多表查询\r#\r\r资料准备\n-- table1 : create table user1(id number(3), user_name varchar(10), over varchar(10)); insert into user1 values(1, \u0026#39;tangseng\u0026#39;, \u0026#39;dtgdf\u0026#39;); insert into user1 values(2, \u0026#39;sunwukong\u0026#39;, \u0026#39;dzsf\u0026#39;); insert into user1 values(1, \u0026#39;zhubajie\u0026#39;, \u0026#39;jtsz\u0026#39;); insert into user1 values(1, \u0026#39;shaseng\u0026#39;, \u0026#39;jslh\u0026#39;); -- table2 : create table user2(id number(3), user_name varchar(10), over varchar(10)); insert into user2 values(1, \u0026#39;sunwukong\u0026#39;, \u0026#39;chengfo\u0026#39;); insert into user2 values(2, \u0026#39;niumowang\u0026#39;, \u0026#39;chengyao\u0026#39;); insert into user2 values(3, \u0026#39;jiaomowang\u0026#39;, \u0026#39;chengyao\u0026#39;); insert into user2 values(4, \u0026#39;pengmowang\u0026#39;, \u0026#39;chengyao\u0026#39;); INNER 内连接\r#\r\r\rselect a.id, a.user_name, b.over from user1 a inner join user2 b on a.user_name=b.user_name; ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\r LEFT/RIGHT\r#\r\rLEFT\r#\r\r\r left join是left outer join的缩写，outer 可以不写\n select a.id, a.user_name, b.over from user1 a left outer join user2 b on a.user_name=b.user_name; ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\r1 shaseng\r1 zhubajie\r1 tangseng\r RIGHT\r#\r\r\r left join和right join区别就是量表的顺序不同，所以 a left join b和b right join a 是完全等效的，所以right join不必学习，使用时仅使用left join即可\n select b.user_name, b.over, a.over from user1 a right join user2 b on a.user_name=b.user_name; USER_NAME OVER OVER\r---------- ---------- ----------\rsunwukong chengfo dzsf\rniumowang chengyao\rjiaomowang chengyao\rpengmowang chengyao\r FULL\r#\r\r\r select a.id, a.user_name, b.over from user1 a full join user2 b on a.user_name=b.user_name ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\rchengyao\rchengyao\rchengyao\r1 shaseng\r1 zhubajie\r1 tangseng\r 笛卡尔连接(交叉连接)\r#\r\r\r a,b是a cross b的缩写，通常情况下，我们会进一步使用 where 条件筛选资料\n select a.id,a.user_name,b.id,b.user_name from user1 a,user2 b; ID USER_NAME ID USER_NAME\r---- ---------- ---- ----------\r1 tangseng 1 sunwukong\r1 tangseng 2 niumowang\r1 tangseng 3 jiaomowang\r1 tangseng 4 pengmowang\r2 sunwukong 1 sunwukong\r2 sunwukong 2 niumowang\r2 sunwukong 3 jiaomowang\r2 sunwukong 4 pengmowang\r1 zhubajie 1 sunwukong\r1 zhubajie 2 niumowang\r1 zhubajie 3 jiaomowang\r1 zhubajie 4 pengmowang\r1 shaseng 1 sunwukong\r1 shaseng 2 niumowang\r1 shaseng 3 jiaomowang\r1 shaseng 4 pengmowang\r select a.id, a.user_name, b.over from user1 a,user2 b where a.user_name=b.user_name;  以上笛卡尔连接，配合where条件等效以下内连接，所以内连接也不需要学。\n select a.id, a.user_name, b.over from user1 a inner join user2 b on a.user_name=b.user_name; ID USER_NAME OVER\r---- ---------- ----------\r2 sunwukong chengfo\r 总结\r#\r\r综上所述，我们只要笛卡尔连接，和LEFT左连接就可以解锁99%的场景，剩下1%场景，我们可以使用代码协助。\n  笛卡尔连接，两个表都存在数据，才会显示出来\n  LEFT 连接，只要左表存在数据，右表数据为NULL也会显示出来\n  "},{"id":6,"href":"/docs/SQL/first/DML/","title":"DML--数据操作语言","section":"SQL--结构化查询语言","content":"DML\u0026ndash;数据操作语言\r#\r\r新增\r#\r\r已知表student结构如下:\ncreate table student(  id number(10),  name varchar(20),  sex varchar(20),  age number(5),  birthday date ) insert into student values(1,\u0026#39;张三\u0026#39;,\u0026#39;男\u0026#39;,19,to_date(\u0026#39;951221\u0026#39;,\u0026#39;yymmdd\u0026#39;)); insert into student (name,id,age) values(\u0026#39;小红\u0026#39;,2,19); 修改\r#\r\r ID NAME SEX AGE BIRTHDAY\r----------- -------------------- -------------------- ------ -----------\r1 张三 男 19 2095-12-21\r2 小红 19  student资料如上\n-- 1.更新小红性别为女 update student set sex=\u0026#39;女\u0026#39; where name=\u0026#39;小红\u0026#39;; -- 2.将所有人年龄更新为12 update student set age=12; 删除\r#\r\r ID NAME SEX AGE BIRTHDAY\r----------- -------------------- -------------------- ------ -----------\r1 张三 男 12 2095-12-21\r2 小红 女 12  student资料如上\n-- 1. 删除所有性别为男资料 delete from student where sex=\u0026#39;男\u0026#39;; -- 2. 删除所有资料 delete from student;  update和delete使用到了where语句，我们在select中会详细介绍和使用。\n "},{"id":7,"href":"/docs/SQL/first/SELECT/group/","title":"聚合查询","section":"查询语句详解","content":"聚合查询\r#\r\r聚合查询是一个比较特殊的查询，它不返回数据，而是返回一个聚合结果，比如求和、平均值、最大值、最小值等。\n数据准备:\nCREATE TABLE sales(  location varchar2(10),  product varchar2(10),  price number(3),  sold_at date );  INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate-1); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;Downtown\u0026#39;, \u0026#39;Bagel\u0026#39;, 3, sysdate-3); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;Downtown\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate-2); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Bagel\u0026#39;, 2, sysdate-2); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;1st Street\u0026#39;, \u0026#39;Bagel\u0026#39;, 3, sysdate-1); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;1st Street\u0026#39;, \u0026#39;Coffee\u0026#39;, 2, sysdate-1); INSERT INTO sales(location, product, price, sold_at) VALUES(\u0026#39;HQ\u0026#39;, \u0026#39;Bagel\u0026#39;, 3, sysdate-5); GROUP-BY\r#\r\r GROUP BY位置紧跟WHERE条件之后\n GROUP-BY 是聚合函数的核心，SELECT的查询结果会依据GROUP BY字段进行汇总。\nSELECT location FROM sales GROUP BY location; LOCATION\r----------\rHQ\rDowntown\r1st Street\r 试一下以下查询：\nSELECT  location,  product FROM sales GROUP BY location; 聚合函数\r#\r\r sum() 合计 count() 计数 avg() 平均值 max() 最大值 min() 最小值  SELECT  location,  COUNT(*) AS number_of_sales FROM sales GROUP BY location; LOCATION NUMBER_OF_SALES\r---------- ---------------\rHQ 4\rDowntown 2\r1st Street 2\r SELECT  location，  sold_at,  COUNT(*) AS sales_per_day FROM sales GROUP BY location,sold_at ORDER BY location,sold_at; LOCATION SOLD_AT SALES_PER_DAY\r---------- ----------- -------------\r1st Street 2023-10-15 2\rDowntown 2023-10-13 1\rDowntown 2023-10-14 1\rHQ 2023-10-11 1\rHQ 2023-10-14 1\rHQ 2023-10-15 1\rHQ 2023-10-16 1\r HAVING\r#\r\r 紧跟GROUP BY\n 在聚合的基础上进行筛选。\nSELECT  location，  sold_at,  COUNT(*) AS sales_per_day FROM sales GROUP BY location,sold_at HAVING COUNT(*) = 1 ORDER BY location,sold_at; LOCATION SOLD_AT SALES_PER_DAY\r---------- ----------- -------------\rDowntown 2023-10-13 1\rDowntown 2023-10-14 1\rHQ 2023-10-11 1\rHQ 2023-10-14 1\rHQ 2023-10-15 1\rHQ 2023-10-16 1\r 隐式聚合\r#\r\rselect count(*) from sales; COUNT(*)\r----------\r8\r 总结\r#\r\rSELECT 中关键字顺序：\n SELECT 必须 FROM 必须 JOIN WHERE GROUP BY HAVING ORDER BY  "},{"id":8,"href":"/docs/SQL/first/SELECT/","title":"查询语句详解","section":"SQL--结构化查询语言","content":"SELECT\u0026ndash;查询语句详解\r#\r\r查询语句组成\r#\r\r结果\u0026ndash;字段（select）\r#\r\r 查询语句的最前面\n select 字段1,字段2,字段3,\u0026#39;6班\u0026#39; 班级  * 匹配所有字段:  select * select student.*,class.*   字面常量： 数值和字符串都可以以字面常量作为字段结果\n  别名：\n  select id,name 姓名,age as 年纪 查询结果中会以别名显示\n 字段运算:  select id,\u0026#39;姓名\u0026#39;||name,age+2 查询字段可以进行字段运算，字符串拼接为||拼接，数学运算符号+-*/都可以使用\n 判断语句： SQL 中判断语句比较特殊，它只能返回一个值，且每个分支返回值必须一致。  -- 从一个变量的值判断 select case sex when \u0026#39;男\u0026#39; then \u0026#39;我是男生\u0026#39; when \u0026#39;女\u0026#39; then \u0026#39;我是女生\u0026#39; else \u0026#39;我是人妖\u0026#39; end as 性别 -- 从条件表达式判断 select case when age \u0026lt; 8 then \u0026#39;小学生\u0026#39; when age \u0026lt; 16 then \u0026#39;初中生\u0026#39; when age \u0026lt; 24 \u0026#39;大学生\u0026#39; else \u0026#39;老人\u0026#39; end as 年纪 来源\u0026ndash;表（from）\r#\r\r 必须在字段之后\n from student,class  别名：  from student as s  表字段:  select s.id,class.id from student as s,class 当多个表中字段有重名时，使用字段必须指定字段属于哪个表\n条件\u0026ndash;判断语句（where）\r#\r\r 必须放在 from 之后\n where student.id \u0026gt; 1 and student.name like \u0026#39;张%\u0026#39; and student.id=class.id and (student.age \u0026gt; 18 or student.age \u0026lt; 10) and student.birth between to_date(\u0026#39;2000-01-01\u0026#39;,\u0026#39;yyyy-mm-dd\u0026#39;) and to_date(\u0026#39;2020-12-31\u0026#39;,\u0026#39;yyyy-mm-dd\u0026#39;) and sex in (\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;)  where 可以从众多的资料中筛选出符号目标要求的资料，所以 where 在查询语句中是最复杂的。\n  我们在写 where 语句的时候，应该从简单语句开始写，分块写，防止多个筛选条件混合到一起。\n  比较运算符： 大于、小于、等于这些运算符在 where 中也可以写。  \u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;/!=\n 逻辑运算符： 多个运算符之间用and或者or相连。 括号会改变判断语句运算顺序  -- 年纪大于10岁或者小于5岁的女人 where (age \u0026gt; 10 or age \u0026lt; 5) and sex =\u0026#39;女\u0026#39; -- 年纪大于10岁的人或者小于5岁的女人 where age \u0026gt; 10 or (age \u0026lt; 5 and sex =\u0026#39;女\u0026#39;)  模糊查询： 字符串模糊查询，like 运算符， %匹配任意多(包括 0)个任意字符， _匹配一个任意字符  -- 匹配\u0026#39;张\u0026#39;开始的字符串 张三 张 张98ahs 等都符和 where name like \u0026#39;张%\u0026#39; -- 匹配\u0026#39;张\u0026#39;开始，且后面之后一个字符的字符串 张三 张四 张w 符和 张 张sw 不符合 where name like \u0026#39;张_\u0026#39; -- 匹配字符中有一个\u0026#39;h\u0026#39;和\u0026#39;o\u0026#39;,且\u0026#39;h\u0026#39;在\u0026#39;o\u0026#39;前面， hello hsasaodaidup ooohhooo 都符和 where name like \u0026#39;%h%o\u0026#39;  between 范围判断:  between 可以判断一个连续的区间，数值，日期，单个字符都可以判断。\n 这里的and 和上面的and不是同一个意思。\n -- 年纪在1到10之间 where age between 1 and 10  in 范围判断： in 判断一个值是否在某个范围之内，这个不是连续的，而是一个集合。  -- 年纪是1，2，10 where age in (1,2,10) -- 年纪不是18，19 where age not in (18,19) -- 可以是多个字段 where (name,age) in ((\u0026#39;darcy\u0026#39;,19),(\u0026#39;joven\u0026#39;,10)) 顺序\u0026ndash;排序（order-by）\r#\r\r 在 sql 语句的最后一步写，不一定是 where 后\n  可以不排序，此时数据库按照查出来的顺序排序\n order by name,age desc,id esc   多字段： 排序是按照字段先后顺序排，如果第一个字段有相同，才会按照第二个字段排序，第二个也相同，才会按第三个\u0026hellip;\n  顺序/倒叙: 顺序是按照 ASCII 表中数字大小排序的，中文是按照 GBK 表中数字大小排序的（既不是笔画也不是拼音）。\n  esc是顺序，desc是倒叙，如果补标注默认是esc倒叙\n"},{"id":9,"href":"/docs/SQL/first/SELECT/nest/","title":"嵌套查询","section":"查询语句详解","content":"嵌套查询\r#\r\r资料准备：\nCREATE TABLE CUSTOMERS (  ID number(2),  NAME VARCHAR2(8),  AGE number(3),  ADDRESS VARCHAR2 (10),  SALARY number (10, 2) );  INSERT INTO CUSTOMERS VALUES (1, \u0026#39;Ramesh\u0026#39;, 32, \u0026#39;Ahmedabad\u0026#39;, 2000.00); INSERT INTO CUSTOMERS VALUES (2, \u0026#39;Khilan\u0026#39;, 25, \u0026#39;Delhi\u0026#39;, 1500.00); INSERT INTO CUSTOMERS VALUES (3, \u0026#39;Kaushik\u0026#39;, 23, \u0026#39;Kota\u0026#39;, 2000.00); INSERT INTO CUSTOMERS VALUES (4, \u0026#39;Chaitali\u0026#39;, 25, \u0026#39;Mumbai\u0026#39;, 6500.00); INSERT INTO CUSTOMERS VALUES (5, \u0026#39;Hardik\u0026#39;, 27, \u0026#39;Bhopal\u0026#39;, 8500.00); INSERT INTO CUSTOMERS VALUES (6, \u0026#39;Komal\u0026#39;, 22, \u0026#39;Hyderabad\u0026#39;, 4500.00); INSERT INTO CUSTOMERS VALUES (7, \u0026#39;Muffy\u0026#39;, 24, \u0026#39;Indore\u0026#39;, 10000.00); 作为结果-SELECT\r#\r\r作为查询结果字段，这个时候要保证每次查询结果只有一个值。\n查询每个人的薪水和最高薪水的差异金额\nselect a.name,a.salary,a.salary-(select max(b.salary) from customers b) salary_diff from customers a; NAME SALARY SALARY_DIFF\r-------- ------------ -----------\rRamesh 2000.00 -8000\rKhilan 1500.00 -8500\rKaushik 2000.00 -8000\rChaitali 6500.00 -3500\rHardik 8500.00 -1500\rKomal 4500.00 -5500\rMuffy 10000.00 0\r 作为条件-WHERE\r#\r\rin\r#\r\r查询工资不是最高也不是最低的人\nselect name,salary from customers where salary not in (  (select max(salary) from customers),  (select min(salary) from customers) ); NAME SALARY\r-------- ------------\rRamesh 2000.00\rKaushik 2000.00\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\r in除了查询单个值，还可以作为范围条件。\nselect name,salary from customers where salary in (select salary from customers where salary \u0026gt; 4000);  和in 一样，这里可以是多字段\n 以上查询，查询薪水大于 4000 的人，当然有更简单的方式写，这里知识演示用法。\nNAME SALARY\r-------- ------------\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\rMuffy 10000.00\r exists\r#\r\rexists和in可以互相转化，查询工资不是最高也不是最低的人改为exists写为：\nselect a.name,a.salary from customers a where not exists (select max(b.salary) from customers b having max(b.salary)=a.salary) and not exists (select min(b.salary) from customers b having max(b.salary)=a.salary); NAME SALARY\r-------- ------------\rRamesh 2000.00\rKhilan 1500.00\rKaushik 2000.00\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\r 作为字段\r#\r\r和SELECT一样，在WHERE查询条件中，也可以将子查询作为查询条件，这个时候要保证查询结果只有一个值。\n同样是查询工资不是最高也不是最低的人\nselect name,salary from customers where salary \u0026lt; (select max(salary) from customers) and salary \u0026gt; (select min(salary) from customers); NAME SALARY\r-------- ------------\rRamesh 2000.00\rKaushik 2000.00\rChaitali 6500.00\rHardik 8500.00\rKomal 4500.00\r 作为来源-FROM\r#\r\r查询结果可以当作一个表使用，即可以作为FROM和JOIN的来源。这个时候要保证，列名不重复（因为表的列名不重复）。\n查询工资最高的人的姓名和地址\nselect a.name,a.address,a.salary from customers a,(select max(salary) salary from customers) b where a.salary=b.salary; NAME ADDRESS SALARY\r-------- ---------- ------------\rMuffy Indore 10000.00\r 总结\r#\r\r  查询结果为多笔时，可用在FROM、JOIN、IN、EXISTS\n  查询结果为单笔，可以当作字段、单个值使用\n  "},{"id":10,"href":"/docs/SQL/first/SELECT/function/","title":"常用函数","section":"查询语句详解","content":"常用函数\r#\r\r数字\r#\r\r绝对值\r#\r\rselect abs(-12) from dual; select abs(12) from dual; 取整\r#\r\r-- 大于该数的最小整数 select ceil(20.2) from dual; -- 小于该数的最大整数 select floor(20.2) from dual; 四舍五入\r#\r\rselect round(20.679,2) from dual 求余数\r#\r\rselect mod(10,3) from dual 截取部分值\r#\r\rselect trunc(20.9987,3) from dual 字符串\r#\r\r拼接\r#\r\rselect \u0026#39;hello\u0026#39;||\u0026#39; world\u0026#39;||\u0026#39;!\u0026#39; from dual; 大小写\r#\r\rselect lower(\u0026#39;Hello\u0026#39;) from dual; select upper(\u0026#39;Hello\u0026#39;) from dual; 替换\r#\r\rselect replace(\u0026#39;hello,darcy\u0026#39;,\u0026#39;darcy\u0026#39;,\u0026#39;joven\u0026#39;)from dual; 去空格\r#\r\rselect \u0026#39;hi,\u0026#39;||rtrim(\u0026#39; hello \u0026#39;)||\u0026#39;joven\u0026#39; from dual; select \u0026#39;hi,\u0026#39;||ltrim(\u0026#39; hello \u0026#39;)||\u0026#39;joven\u0026#39; from dual; select \u0026#39;hi,\u0026#39;||trim(\u0026#39; hello \u0026#39;)||\u0026#39;joven\u0026#39; from dual; 截取部分字符串\r#\r\rselect substr(\u0026#39;hello world\u0026#39;,8,2) from dual; 日期\r#\r\r当前时间\r#\r\rselect current_date,sysdate from dual; 最近日期\r#\r\rselect round(sysdate,\u0026#39;yyyy\u0026#39;),round(sysdate,\u0026#39;mm\u0026#39;),round(sysdate,\u0026#39;dd\u0026#39;),round(sysdate,\u0026#39;hh\u0026#39;) from dual; 截取日期\r#\r\rselect trunc(sysdate,\u0026#39;yyyy\u0026#39;),trunc(sysdate,\u0026#39;mm\u0026#39;),trunc(sysdate,\u0026#39;dd\u0026#39;),trunc(sysdate,\u0026#39;hh\u0026#39;) from dual; 日期与字符串转换\r#\r\rselect to_char(sysdate,\u0026#39;yy/mm/dd hh:mi:ss\u0026#39;), to_date(\u0026#39;231017\u0026#39;,\u0026#39;yymmdd\u0026#39;) from dual 日期计算\r#\r\rselect sysdate-1, sysdate + 1/24/2 from dual "},{"id":11,"href":"/docs/SQL/first/SELECT/view/","title":"视图","section":"查询语句详解","content":"视图\r#\r\r视图-VIEW是通过查询结果建立的一个对象\n 视图必须通过查询结果建立，列名不可重复 视图不储存数据，数据仍在原表 视图每次查询重新查询资料  建立视图\r#\r\rcreate view stu_view as select name,id form student 删除视图\r#\r\rdrop view stu_view 重建视图\r#\r\rcreate or replace view stu_view as select name,id form student "},{"id":12,"href":"/docs/SQL/first/SELECT/dmlBySelect/","title":"使用SELECT更新数据","section":"查询语句详解","content":"使用SELECT更新数据\r#\r\r新增数据-INSERT\r#\r\r在insert语句中除了使用values()还可以使用select，且查询结果可以是多笔。\ninsert into student (id,name) select id,name from student2; 创建表-CREATE\r#\r\r和创建视图一样，通过SELECT还可以创建table\ncreate table student3 as select id,name from student2; "}]